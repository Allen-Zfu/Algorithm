/* 给一个数组，里面是一些int，每一个自然是被表示为32位的0/1。它们的前28位都排好了，而后面4位是乱序的。
问怎样比较高效率地将这个数组里的所有数彻底排好序。
比如，这个数组里的数从左到右可能分别是（用二进制表达如下。实际上肉眼看到的都是十进制数）：
00001 XXXX
00001 XXXX
...
00011 XXXX
...
00101 XXXX
00101 XXXX
00101 XXXX
...
01111 XXXX
01111 XXXX
...

思路：
第一步，在给定的数组里，从左到右，查找每一段共享前28位的数字们的起始和终止位置，即把各个区段找到，每个区段内的数字们的前28位都是相同的
    最后四位的表示范围是0到15. 所以看两个数的前28位是否相等，就是看它们分别除以16，商是否相等即可 ！！
第二步，在每个区段内，排序数字们。这一步应该用另外写的private helper method来做。
    因为只有最后4位不同，而最后4位只能表示0到15，所以要解决这一步，最快的方法是 Counting Sort 类型的方法！！！
    就像一个一个扔到桶里去一样。时间仅仅需要 O(n) ！ 
    具体做法：设立0到15一共十五个"桶"。在当前区间里，从左到右看各个数的最后4位，即这些数除以16的余数，必然是0到15之间的一个数，
    看到一个就扔一个到相应的桶里去。然后最后从最小的0桶到最大的15桶逐个数一遍，相应地填入这些数。
    比如0桶里有3个数，就证明最后4位为0的数有3个，那么就从区间的最左端写3个数就行了，这3个数满足前28位是共同的值，后4位是0.
    然后1桶里如果有0个数，就忽略。
    然后2桶里如果有2个数，就按照上述方式来做
    ......
*/

